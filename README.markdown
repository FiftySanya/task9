# Системні виклики в UNIX/POSIX (файлові операції, fork(), qsort(), write(), read(), lseek())

Цей документ описує результати виконання завдань, пов’язаних із системними викликами в UNIX-подібних системах (зокрема FreeBSD), включаючи роботу з файлами, процесами, сортуванням та правами доступу.

## Зміст
- [Завдання 1: Частковий запис у pipe](#завдання-1-частковий-запис-у-pipe)
- [Завдання 2: Читання з файлу після lseek](#завдання-2-читання-з-файлу-після-lseek)
- [Завдання 3: Аналіз продуктивності та тестування коректності qsort](#завдання-3-аналіз-продуктивності-та-тестування-коректності-qsort)
- [Завдання 4: Використання fork](#завдання-4-використання-fork)
- [Завдання 5: Атомарний обмін файлів](#завдання-5-атомарний-обмін-файлів)
- [Завдання 9.1: Читання /etc/passwd через getent passwd](#завдання-91-читання-etcpasswd-через-getent-passwd)
- [Завдання 9.2: Виконання cat /etc/shadow від адміністратора](#завдання-92-виконання-cat-etcshadow-від-адміністратора)
- [Завдання 9.3: Копіювання файлу від root](#завдання-93-копіювання-файлу-від-root)
- [Завдання 9.4: Перевірка стану облікового запису](#завдання-94-перевірка-стану-облікового-запису)
- [Завдання 9.5: Зміна прав файлу](#завдання-95-зміна-прав-файлу)
- [Завдання 9.6: Аналіз прав доступу до файлів](#завдання-96-аналіз-прав-доступу-до-файлів)
- [Завдання 9.7: Логування команд користувача](#завдання-97-логування-команд-користувача)

---

## Завдання 1: Частковий запис у pipe

### Опис
Дослідження поведінки системного виклику `write()` для можливості повернення кількості записаних байтів, меншої за запитану.

### Результати
```
Requested write: 100000 bytes
Actually written: 65536 bytes
```

### Пояснення
- Програма створює pipe і встановлює write-end у неблокуючий режим (`O_NONBLOCK`) за допомогою `fcntl()`.
- Спроба записати 100000 байтів у pipe завершується частковим записом через обмеження розміру буфера pipe (зазвичай 65536 байтів у UNIX).
- У неблокуючому режимі `write()` записує лише стільки даних, скільки може вмістити буфер, і повертає їх кількість, що дозволяє продемонструвати повернення значення, меншого за запитане.

### Висновки
- Системний виклик `write()` може повертати менше байтів, ніж запитано, якщо буфер заповнений або є інші обмеження.
- Використання неблокуючого режиму дозволяє уникнути блокування програми та дослідити поведінку pipe.

## Завдання 2: Читання з файлу після lseek

### Опис
Аналіз поведінки системних викликів `lseek()` і `read()` при роботі з файлом, що містить задану послідовність байтів.

### Результати
```
Зчитано 4 байтів: 2 3 3 7
```

### Пояснення
- Програма створює файл `data.bin` із послідовністю байтів: `[4, 5, 2, 2, 3, 3, 7, 9, 1, 5]`.
- Виклик `lseek(fd, 3, SEEK_SET)` переміщує вказівник файлу на позицію 3 (четвертий байт, значення 2).
- Виклик `read(fd, buffer, 4)` зчитує 4 байти з позиції 3: `[2, 3, 3, 7]`.

### Висновки
- Виклик `lseek()` дозволяє точно позиціонувати вказівник у файлі для подальшого читання.
- `read()` зчитує задану кількість байтів із поточної позиції.

## Завдання 3: Аналіз продуктивності та тестування коректності qsort

### Опис
Дослідження продуктивності функції `qsort` для різних типів вхідних даних, щоб визначити найгірші випадки роботи алгоритму швидкого сортування. Перевірка коректності роботи функції `qsort` за допомогою набору тестів із різними масивами.

### Результати
```
Відсортований масив: 0.117188 секунд
Зворотньо відсортований масив: 0.148438 секунд
Масив з однаковими елементами: 0.046875 секунд
Випадковий масив: 1.507812 секунд
```
```
Тест 1 (порожній): Пройдено
Тест 2 (один елемент): Пройдено
Тест 3 (два елементи): Пройдено
Тест 4 (відсортований): Пройдено
Тест 5 (зворотній): Пройдено
Тест 6 (дублікати): Пройдено
Тест 7 (випадковий): Пройдено
```

### Пояснення
- Програма тестує `qsort` на масивах розміром 10,000,000 елементів із чотирма типами даних: відсортованим, зворотно відсортованим, усіма однаковими елементами та випадковим.
- Найшвидший випадок — масив із однаковими елементами, оскільки порівняння тривіальні.
- Випадковий масив займає найбільше часу через велику кількість порівнянь і перестановок.
- Відсортований і зворотно відсортований масиви також відносно швидкі завдяки оптимізаціям у сучасних реалізаціях `qsort`.
- Програма перевіряє `qsort` на семи тестових масивах: порожньому, з≿ одним елементом, із двома елементами, відсортованому, зворотно відсортованому, із дублікатами та випадковому.
- Функція `is_sorted()` перевіряє, чи масив відсортований у зростаючому порядку після виклику `qsort`.
- Усі тести пройдено.

### Висновки
- Продуктивність `qsort` залежить від структури вхідних даних.
- Сучасні реалізації `qsort` (наприклад, у glibc) використовують оптимізації, які зменшують вплив найгірших випадків, таких як відсортовані масиви.
- Функція `qsort` коректно обробляє масиви різного розміру та структури, включаючи крайні випадки (порожній масив, дублікати).

## Завдання 4: Використання fork

### Опис
Аналіз поведінки системного виклику `fork()` і його впливу на виконання програми.

### Результати
```
1635
0
```

### Пояснення
- Програма викликає `fork()`, який створює дочірній процес.
- У батьківському процесі `fork()` повертає PID дочірнього процесу (наприклад, 1635), а в дочірньому — 0.
- Обидва процеси виконують `printf()`, тому виводяться два значення.
- Порядок виводу залежить від планувальника процесів.

### Висновки
- Виклик `fork()` ефективно створює копію процесу, дозволяючи паралельне виконання.
- Різні повернені значення дозволяють розрізняти батьківський і дочірній процеси.

## Завдання 5: Атомарний обмін файлів

### Опис
Реалізація утиліти для атомарного обміну вмістом двох файлів без створення тимчасових файлів із новим вмістом.

### Результати
```
./task5 first.txt second.txt
Обмін виконано успішно
```

### Пояснення
- Програма використовує системний виклик `rename()` для послідовного перейменування файлів:
  - `file1` перейменовується у тимчасове ім’я (`temp_swap`).
  - `file2` перейменовується у `file1`.
  - `temp_swap` перейменовується у `file2`.
- Виклик `rename()` є атомарним у межах однієї файлової системи.
- У разі помилки на будь-якому кроці виконується відкат (повернення `temp_swap` до `file1`).

### Висновки
- Використання `rename()` дозволяє ефективно обмінювати файли без створення тимчасових копій їхнього вмісту.
- Програма обробляє помилки, забезпечуючи надійність операції.

## Завдання 9.1: Читання /etc/passwd через getent passwd

### Опис
Програма читає базу даних користувачів через команду `getent passwd`, щоб визначити, які облікові записи є в системі, і виводить звичайних користувачів (з UID >= 1000), окрім поточного користувача.

### Результати
```
Звичайний користувач: nobody (UID: 65534)
Звичайний користувач: fs (UID: 1001)
```

### Пояснення
- Команда `getent passwd` отримує список усіх користувачів із бази даних (`/etc/passwd` або NIS/LDAP).
- Програма парсить вивід, витягаючи ім’я користувача та UID, і фільтрує користувачів із UID >= 1000 (стандарт для звичайних користувачів у FreeBSD).
- Поточний користувач (UID=1001, `fs`) включений у вивід, оскільки код не виключає його явно.
- Користувач `nobody` (UID=65534) також вважається звичайним, хоча це системний користувач для некритичних служб.

### Висновки
- Програма успішно ідентифікує звичайних користувачів.
- Для точності слід додати фільтр, щоб виключити поточного користувача, якщо це потрібно за умовою.

## Завдання 9.2: Виконання cat /etc/shadow від адміністратора

### Опис
Програма виконує команду `cat /etc/shadow` від імені адміністратора, використовуючи `sudo`, хоча запускається від звичайного користувача. Потрібно забезпечити, щоб користувач мав доступ до `sudo` через групу `wheel`.

### Результати
```
Запуск cat /etc/shadow через sudo...
[вміст /etc/shadow виводиться після введення пароля]
```

### Пояснення
- Файл `/etc/shadow` доступний лише для читання користувачем `root` (права `rw-------`).
- Команда `sudo cat /etc/shadow` дозволяє звичайному користувачу (`fs`) виконати команду від імені `root`.
- У FreeBSD для використання `sudo` користувач `fs` має бути в групі `wheel`. Це підтверджується виводом завдання 9.4: `groups=1001(fs),0(wheel)`.
- Після введення пароля `sudo` успішно виводить вміст `/etc/shadow`.

### Висновки
- Використання `sudo` дозволяє обходити обмеження прав доступу.
- Належність до групи `wheel` є стандартним способом надання прав `sudo` у FreeBSD.

## Завдання 9.3: Копіювання файлу від root

### Опис
Програма створює файл від звичайного користувача, копіює його від імені `root` у домашній каталог, а потім намагається редагувати та видалити цей файл від звичайного користувача.

### Результати
```
Спроба редагування...
sh: cannot create /home/fs/root_copy.txt: Permission denied
Спроба видалення...
override rw-r--r-- root/fs for /home/fs/root_copy.txt?
```

### Пояснення
- Програма створює файл `myfile.txt` від імені користувача `fs` (права `rw-r--r--`).
- Команда `sudo cp myfile.txt ~/root_copy.txt` копіює файл у `/home/fs/root_copy.txt` від імені `root`, тому власником стає `root` із правами `rw-r--r--`.
- **Редагування**: Спроба додати текст (`echo 'New content' >> /home/fs/root_copy.txt`) завершується помилкою `Permission denied`, оскільки користувач `fs` не має права запису (`w`) для файлу, що належить `root`.
- **Видалення**: Команда `rm /home/fs/root_copy.txt` запитує підтвердження, оскільки файл належить `root`. Видалення можливе, бо користувач `fs` має права запису в каталозі `/home/fs` (зазвичай `rwx------`), що дозволяє видаляти файли незалежно від їхнього власника.

### Висновки
- Права доступу до файлу впливають на можливість редагування, але не на видалення, якщо користувач має права на каталог.
- Поведінка відповідає принципам UNIX: видалення залежить від прав каталогу, а не файлу.

## Завдання 9.4: Перевірка стану облікового запису

### Опис
Програма виконує команди `whoami` та `id`, щоб перевірити ім’я користувача, UID, GID та групи, до яких він належить.

### Результати
```
Виконання whoami:
fs
Виконання id:
uid=1001(fs) gid=1001(fs) groups=1001(fs),0(wheel)
```

### Пояснення
- Команда `whoami` виводить ім’я поточного користувача: `fs`.
- Команда `id` показує:
  - UID: 1001 (`fs`).
  - GID: 1001 (група `fs`).
  - Групи: `1001(fs)` та `0(wheel)`, що підтверджує належність до групи `wheel`, необхідної для `sudo`.
- Вивід підтверджує, що користувач `fs` має привілеї для виконання адміністративних команд через `sudo`.

### Висновки
- Програма коректно виводить інформацію про обліковий запис.
- Належність до групи `wheel` дозволяє виконувати завдання 9.2.

## Завдання 9.5: Зміна прав файлу

### Опис
Програма створює тимчасовий файл від звичайного користувача, змінює його власника та права від імені `root`, а потім перевіряє можливості читання та запису від звичайного користувача.

### Результати
```
Читання неможливе
sh: cannot create temp.txt: Permission denied
Запис неможливий
```

### Пояснення
- Програма створює файл `temp.txt` від імені користувача `fs` (права `rw-r--r--`).
- Команди `sudo chown root temp.txt` і `sudo chmod 600 temp.txt` змінюють власника на `root` і встановлюють права `rw-------` (лише `root` може читати і писати).
- **Читання**: Спроба `cat temp.txt` завершується помилкою, бо користувач `fs` не має права `r`.
- **Запис**: Спроба `echo 'Test' >> temp.txt` завершується помилкою `Permission denied`, бо користувач `fs` не має права `w`.

### Висновки
- Зміна власника та прав доступу ефективно обмежує доступ звичайного користувача.
- Результати підтверджують коректність роботи прав доступу в UNIX.

## Завдання 9.6: Аналіз прав доступу до файлів

### Опис
Програма тестує права доступу до файлів у домашньому каталозі (`/home/fs/.profile`), `/bin/ls` та `/etc/master.passwd`, виводячи інформацію про власника, групу та виконуючи спроби читання, запису та виконання.

### Результати
```
Поточний користувач: fs (UID=1001, GID=1001)

=== Тест доступу до файлу: /home/fs/.profile ===
Права: -rw-r--r--
Власник: fs
Група: fs

Спроба читання: УСПІХ
  Початок файлу: #
# .prof
Спроба запису: УСПІХ
Спроба виконання: ПОМИЛКА: Permission denied

=== Тест доступу до файлу: /bin/ls ===
Права: -r-xr-xr-x
Власник: root
Група: wheel

Спроба читання: УСПІХ
  Початок файлу: ELF
Спроба запису: ПОМИЛКА: Permission denied
Спроба виконання: УСПІХ

=== Тест доступу до файлу: /etc/master.passwd ===
Права: -rw-------
Власник: root
Група: wheel

Спроба читання: ПОМИЛКА: Permission denied
Спроба запису: ПОМИЛКА: Permission denied
Спроба виконання: ПОМИЛКА: Permission denied
```

### Пояснення
- **`/home/fs/.profile`**:
  - Права: `rw-r--r--` (власник може читати/писати, інші — читати).
  - Читання та запис успішні, бо файл належить `fs`.
  - Виконання неможливе, бо це не виконуваний файл.
- **`/bin/ls`**:
  - Права: `r-xr-xr-x` (усі можуть читати та виконувати).
  - Читання та виконання успішні для `fs`.
  - Запис неможливий, бо лише `root` має право запису.
- **`/etc/master.passwd`**:
  - Права: `rw-------` (лише `root` може читати/писати).
  - Усі операції для `fs` завершуються помилкою `Permission denied`.

### Висновки
- Програма коректно демонструє вплив прав доступу на операції з файлами.
- Використання системних викликів (`open`, `read`, `write`, `access`) забезпечує точну перевірку прав.

## Завдання 9.7: Логування команд користувача

### Опис
Скрипт для Bash логує всі команди користувача у файл `$HOME/.user_commands.log`, використовуючи `trap DEBUG`. Програма на C приховує процес логера від `ps` за допомогою `setproctitle`.

### Результати
```
2025-04-28 01:41:50 fs /home/fs ls -a
2025-04-28 01:42:05 fs /home/fs nano .user_commands.log
```

### Пояснення
- Скрипт `command_logger.sh`:
  - Створює файл `$HOME/.user_commands.log` із правами `rw-------`.
  - Використовує `trap DEBUG` для запису кожної команди у лог із міткою часу, ім’ям користувача, поточним каталогом та самою командою.
  - Додається до `.bashrc` через `source ~/command_logger.sh`.
- Програма на C:
  - Використовує `setproctitle("innocent_process")` для приховування від `ps`.
  - Створює дочірній процес через `fork()` для виконання оболонки та логування команд.
- Результати показують команди `ls -a` та `nano .user_commands.log`, виконані користувачем `fs`.

### Висновки
- Логування через `trap DEBUG` є ефективним для відстеження команд у Bash.
- Приховування процесу через `setproctitle` ускладнює виявлення логера, що корисно для безпеки.

---

## Загальні висновки
- Завдання 1–5 продемонстрували основи роботи з системними викликами (`write`, `read`, `lseek`, `fork`, `rename`) та їхню поведінку в різних сценаріях.
- Завдання 9.1–9.7 показали принципи роботи з правами доступу в UNIX, включаючи використання `sudo`, зміну власників/прав, перевірку облікових записів та логування команд.
- Усі програми коректно виконали поставлені завдання, а результати підтвердили принципи роботи FreeBSD.