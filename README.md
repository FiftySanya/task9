# Capabilities - огляд можливостей Linux

## Зміст
- [Завдання 1: Читання /etc/passwd через getent passwd](#завдання-1-читання-etcpasswd-через-getent-passwd)
- [Завдання 2: Виконання cat /etc/master.passwd від адміністратора](#завдання-2-виконання-cat-etcmasterpasswd-від-адміністратора)
- [Завдання 3: Копіювання файлу від root](#завдання-3-копіювання-файлу-від-root)
- [Завдання 4: Перевірка стану облікового запису](#завдання-4-перевірка-стану-облікового-запису)
- [Завдання 5: Зміна прав файлу](#завдання-5-зміна-прав-файлу)
- [Завдання 6: Аналіз прав доступу до файлів](#завдання-6-аналіз-прав-доступу-до-файлів)
- [Завдання 7: Логування команд користувача](#завдання-7-логування-команд-користувача)

---

## Завдання 1: Читання /etc/passwd через getent passwd

### Опис
Програма читає базу даних користувачів через команду `getent passwd`, щоб визначити, які облікові записи є в системі, і виводить звичайних користувачів (з UID >= 1000), окрім поточного користувача.

### Результати
```
Звичайний користувач: nobody (UID: 65534)
Звичайний користувач: fs (UID: 1001)
```

### Пояснення
- Команда `getent passwd` отримує список усіх користувачів із бази даних (`/etc/passwd`).
- Програма парсить вивід, витягаючи ім’я користувача та UID, і фільтрує користувачів із UID >= 1000 (стандарт для звичайних користувачів у FreeBSD).
- Поточний користувач (UID=1001, `fs`) включений у вивід.
- Користувач `nobody` (UID=65534) також вважається звичайним, хоча це системний користувач для некритичних служб.

### Висновки
- Програма успішно ідентифікує звичайних користувачів.

## Завдання 2: Виконання cat /etc/master.passwd від адміністратора

### Опис
Програма виконує команду `cat /etc/master.passwd` від імені адміністратора, використовуючи `sudo`, хоча запускається від звичайного користувача. Потрібно забезпечити, щоб користувач мав доступ до `sudo` через групу `wheel`.

### Результати
```
Запуск cat /etc/master.passwd через sudo.
[вміст /etc/master.passwd виводиться після введення пароля]
```

### Пояснення
- Команда `sudo cat /etc/master.passwd` дозволяє звичайному користувачу (`fs`) виконати команду від імені `root`.
- У FreeBSD для використання `sudo` користувач `fs` має бути в групі `wheel`.

### Висновки
- Використання `sudo` дозволяє обходити обмеження прав доступу.
- Належність до групи `wheel` є стандартним способом надання прав `sudo` у FreeBSD.

## Завдання 3: Копіювання файлу від root

### Опис
Програма створює файл від звичайного користувача, копіює його від імені `root` у домашній каталог, а потім намагається редагувати та видалити цей файл від звичайного користувача.

### Результати
```
Спроба редагування...
sh: cannot create /home/fs/root_copy.txt: Permission denied
Спроба видалення...
override rw-r--r-- root/fs for /home/fs/root_copy.txt? no
```

### Пояснення
- Програма створює файл `myfile.txt` від імені користувача `fs` (права `rw-r--r--`).
- Команда `sudo cp myfile.txt ~/root_copy.txt` копіює файл у `/home/fs/root_copy.txt` від імені `root`, тому власником стає `root` із такими ж правами `rw-r--r--`.
- **Редагування**: Спроба додати текст (`echo 'New content' >> /home/fs/root_copy.txt`) завершується помилкою `Permission denied`, оскільки користувач `fs` не має права запису (`w`) для файлу, що належить `root`.
- **Видалення**: Команда `rm /home/fs/root_copy.txt` запитує підтвердження, оскільки файл належить `root`. Видалення можливе, бо користувач `fs` має права запису в каталозі `/home/fs` (зазвичай `rwx------`), що дозволяє видаляти файли незалежно від їхнього власника.

### Висновки
- Права доступу до файлу впливають на можливість редагування, але не на видалення, якщо користувач має права на каталог.
- Поведінка відповідає принципам UNIX: видалення залежить від прав каталогу, а не файлу.

## Завдання 4: Перевірка стану облікового запису

### Опис
Програма виконує команди `whoami` та `id`, щоб перевірити ім’я користувача, UID, GID та групи, до яких він належить.

### Результати
```
Виконання whoami:
fs
Виконання id:
uid=1001(fs) gid=1001(fs) groups=1001(fs),0(wheel)
```

### Пояснення
- Команда `whoami` виводить ім’я поточного користувача: `fs`.
- Команда `id` показує:
  - UID: 1001 (`fs`).
  - GID: 1001 (група `fs`).
  - Групи: `1001(fs)` та `0(wheel)`, що підтверджує належність до групи `wheel`, необхідної для `sudo`.

### Висновки
- Програма коректно виводить інформацію про обліковий запис.
- Вивід підтверджує, що користувач `fs` має привілеї для виконання адміністративних команд через `sudo`.

## Завдання 5: Зміна прав файлу

### Опис
Програма створює тимчасовий файл від звичайного користувача, змінює його власника та права від імені `root`, а потім перевіряє можливості читання та запису від звичайного користувача.

### Результати
```
Читання неможливе
sh: cannot create temp.txt: Permission denied
Запис неможливий
```

### Пояснення
- Програма створює файл `temp.txt` від імені користувача `fs` (права `rw-r--r--`).
- Команди `sudo chown root temp.txt` і `sudo chmod 600 temp.txt` змінюють власника на `root` і встановлюють права `rw-------` (лише `root` може читати і писати).
- **Читання**: Спроба `cat temp.txt` завершується помилкою, бо користувач `fs` не має права `r`.
- **Запис**: Спроба `echo 'Test' >> temp.txt` завершується помилкою `Permission denied`, бо користувач `fs` не має права `w`.

### Висновки
- Зміна власника та прав доступу ефективно обмежує доступ звичайного користувача.

## Завдання 6: Аналіз прав доступу до файлів

### Опис
Програма тестує права доступу до файлів у домашньому каталозі (`/home/fs/.profile`), `/bin/ls` та `/etc/master.passwd`, виводячи інформацію про власника, групу та виконуючи спроби читання, запису та виконання.

### Результати
```
Поточний користувач: fs (UID=1001, GID=1001)

=== Тест доступу до файлу: /home/fs/.profile ===
Права: -rw-r--r--
Власник: fs
Група: fs

Спроба читання: УСПІХ
Початок файлу: #
# .prof
Спроба запису: УСПІХ
Спроба виконання: ПОМИЛКА: Permission denied

=== Тест доступу до файлу: /bin/ls ===
Права: -r-xr-xr-x
Власник: root
Група: wheel

Спроба читання: УСПІХ
Початок файлу: ELF
Спроба запису: ПОМИЛКА: Permission denied
Спроба виконання: УСПІХ

=== Тест доступу до файлу: /etc/master.passwd ===
Права: -rw-------
Власник: root
Група: wheel

Спроба читання: ПОМИЛКА: Permission denied
Спроба запису: ПОМИЛКА: Permission denied
Спроба виконання: ПОМИЛКА: Permission denied
```

### Пояснення
- **`/home/fs/.profile`**:
  - Права: `rw-r--r--` (власник може читати/писати, інші — читати).
  - Читання та запис успішні, бо файл належить `fs`.
  - Виконання неможливе, бо це не виконуваний файл.
- **`/bin/ls`**:
  - Права: `r-xr-xr-x` (усі можуть читати та виконувати).
  - Читання та виконання успішні для `fs`.
  - Запис неможливий, бо лише `root` має право запису.
- **`/etc/master.passwd`**:
  - Права: `rw-------` (лише `root` може читати/писати).
  - Усі операції для `fs` завершуються помилкою `Permission denied`.

### Висновки
- Програма коректно демонструє вплив прав доступу на операції з файлами.

## Завдання 7: Логування команд користувача

### Опис
Скрипт для Bash логує всі команди користувача у файл $HOME/.user_commands.log, використовуючи trap DEBUG. Для приховування логера від утиліти ps використовується C-програма, яка змінює назву процесу за допомогою setproctitle. Скрипт інтегрується в Bash через .bashrc.

### Результати
```
2025-04-28 01:41:50 fs /home/fs ls -a
2025-04-28 01:42:05 fs /home/fs nano .user_commands.log
```

### Пояснення
Скрипт task7.sh:
- Визначає лог-файл $HOME/.user_commands.log.
- Створює або очищає файл із правами rw------- (chmod 600), щоб лише власник мав доступ.
- Використовує trap DEBUG для запису кожної команди в лог із міткою часу (date "+%Y-%m-%d %H:%M:%S"), ім’ям користувача ($USER), поточним каталогом ($PWD) і текстом команди ($BASH_COMMAND).

C-програма task7.c:
- Використовує setproctitle("innocent_process") для зміни назви процесу, видимої в ps, щоб приховати факт логування.
- Викликає task7.sh через execl із запуском /bin/sh.

Інтеграція:
- У ~/.bashrc додається виклик ~/task7, який запускає C-програму.
- Після виконання source ~/.bashrc логування активується, а в ps процес відображається як innocent_process.

### Висновки
- Логування через trap DEBUG є ефективним і простим способом відстеження команд у Bash.
- Використання setproctitle у C-програмі забезпечує надійне приховування логера від утиліти ps.
